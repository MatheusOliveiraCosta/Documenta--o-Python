<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Documentation</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <main id="main-doc">
        <div class="barra_lateral">
            <img src="python-brands.svg" alt="python_icon">
            <ul>
                <li><a href="#"></a></li>

                <li><a href="#"></a></li>

                <li><a href="#"></a></li>

                <li><a href="#"></a></li>

                <li><a href="#"></a></li>

                <li><a href="#"></a></li>

                <li><a href="#"></a></li>

                <li><a href="#"></a></li>
            </ul>
        </div>
        <h1>Python Documentation</h1>
      <section class="main-section">
        <header id="python_intro">
            <h2>Introdução</h2>
            <p>Python é uma linguagem de programação que transformou o cenário do desenvolvimento de software graças à sua simplicidade e versatilidade. Sua história começa no final dos anos 1980, quando Guido van Rossum, trabalhando no Centrum Wiskunde & Informatica (CWI) na Holanda, buscava criar uma linguagem que unisse a facilidade de leitura e escrita com o poder de manipular tarefas complexas. Van Rossum teve como inspiração a linguagem ABC, mas desejava corrigir suas limitações—como a dificuldade de tratar exceções e a pouca extensibilidade—e, assim, nasceu o Python. Sua primeira versão, a 0.9.0, foi lançada em 1991, já incorporando conceitos de orientação a objetos, tratamento de exceções e uma sintaxe limpa que prioriza a legibilidade do código.</p>
            <p>O nome “Python” não faz referência ao réptil, mas sim ao grupo humorístico britânico Monty Python, uma escolha que reflete o espírito descontraído e criativo com que a linguagem foi concebida. Ao longo dos anos, Python evoluiu significativamente. Em 1994, com o lançamento da versão 1.0, a linguagem começou a ganhar tração, consolidando suas bases. Em 2000, o Python 2.0 introduziu importantes melhorias, como compreensões de lista e um coletor de lixo para gerenciar a memória, facilitando a construção de programas mais robustos. A grande mudança veio em 2008 com o Python 3.0, que reformulou diversos aspectos da linguagem—por exemplo, o tratamento de strings passou a usar Unicode e a função de impressão tornou-se um recurso de função, tornando o código mais consistente, ainda que incompatível com as versões anteriores.</p>
        </header>
      </section>

      <section class="main-section">
        <header id="python_filosofia">
            <h2>Filosofia</h2>
            <p>A filosofia do Python se fundamenta na simplicidade e clareza, aspectos expressos no famoso "Zen of Python". Esse conjunto de princípios incentiva os desenvolvedores a escrever código que seja não só funcional, mas também fácil de ler e manter, promovendo ideias como "bonito é melhor que feio" e "explícito é melhor que implícito". Em outras palavras, o Python valoriza a legibilidade e a simplicidade, permitindo que tanto iniciantes quanto programadores experientes possam colaborar de maneira eficaz e evoluir seus projetos de forma sustentável. </p>
        </header> 
      </section>

      <section class="main-section">
        <header id="python_desenvolvimento">
            <h2>Desenvolvimento</h2> 
            <p>Van Rossum decidiu que a nova linguagem precisaria de uma sintaxe clara e intuitiva, adotando a indentação obrigatória para delimitar blocos de código, o que promoveria uma legibilidade sem precedentes. Em 1991, a versão 0.9.0 foi lançada, apresentando desde o início recursos inovadores, como o suporte a classes, funções de primeira classe e um sistema modular que possibilitava a reutilização de código em diferentes contextos. À medida que a linguagem ganhava adeptos, a comunidade global começou a contribuir com melhorias e novos recursos: o Python 1.0, lançado em 1994, consolidou a sua base, enquanto o Python 2.0, em 2000, introduziu avanços como o suporte a Unicode, compreensões de listas e um coletor de lixo para gerenciar a memória de forma automática. Em 2008, o Python 3.0 veio como uma revisão profunda, corrigindo inconsistências acumuladas e modernizando a linguagem — mesmo que, por isso, criasse uma incompatibilidade com códigos escritos para as versões anteriores. Hoje, sob a gestão da Python Software Foundation, o Python continua a evoluir por meio de uma comunidade vibrante que mantém seu compromisso com a simplicidade, a clareza e a eficácia no desenvolvimento de software.</p>
        </header> 
      </section>

      <section class="main-section">
        <header id="variavel">
           <h2>Manipulação de variáveis</h2>
           <p>Em Python, as variáveis são essencialmente nomes que apontam para objetos na memória, permitindo armazenar e manipular dados de forma dinâmica sem a necessidade de declarar explicitamente o tipo. Isso significa que você pode criar, modificar e combinar variáveis de maneira flexível, usando-as para cálculos, manipulação de textos, coleções e muito mais.</p>
           <h3>Exemplo</h3>
           <div class="code-python">
            <p># Atribuição de valores</p>
            <p>x = 10</p>
            <p>y = 20</p>
            <p># Operação com variáveis</p>
            <p>soma = x + y</p>
            <p>print("A soma é:", soma)</p>
           </div>
        </header>
      </section>

      <section class="main-section">
        <header id="modulos_e_frameworks">
            <h2>Módulos e Frameworks</h2>
            <p>Em Python, os módulos são arquivos com extensão “.py” que contêm código reutilizável, como funções, classes e variáveis, permitindo organizar e modularizar os programas.</p>
            <p>Já os frameworks são conjuntos integrados de módulos, bibliotecas e ferramentas que fornecem uma estrutura padrão para o desenvolvimento de aplicações complexas. Eles agilizam a criação de projetos, estabelecendo convenções e implementando funcionalidades comuns.</p>
            <h3>Exemplo de Módulos</h3>
            <ol class="modulo">
              <li>math</li>
              <p>Fornece funções matemáticas avançadas, como operações trigonométricas, exponenciais, logarítmicas e arredondamentos, facilitando cálculos complexos.</p>

              <li>datetime</li>
              <p>Permite manipular datas e horários, possibilitando a criação, formatação e cálculo de intervalos de tempo de forma prática.</p>

              <li>os</li>
              <p>Oferece uma interface para interagir com o sistema operacional, permitindo a manipulação de arquivos, diretórios, variáveis de ambiente, entre outras operações.</p>

              <li>sys</li>
              <p>Fornece acesso a variáveis e funções específicas do interpretador Python, como argumentos de linha de comando e informações sobre o ambiente de execução.</p>

              <li>random</li>
              <p>Gera números aleatórios e permite realizar operações probabilísticas, sendo útil para simulações, jogos e sorteios.</p>

              <li>json</li>
              <p>Facilita a conversão de dados entre o formato JSON e objetos Python, essencial para a troca de informações em APIs e aplicações web.</p>

              <li>re</li>
              <p>Implementa expressões regulares, permitindo buscas e manipulação de padrões em textos de forma eficiente.</p>

              <li>itertools</li>
              <p>Oferece um conjunto de funções para criar iteradores eficientes, úteis na construção de loops e na manipulação de sequências de dados.</p>

              <li>collections</li>
              <p>Amplia as estruturas de dados nativas do Python com classes especializadas, como deque, Counter e defaultdict, para manipulação mais eficiente de coleções.</p>

            </ol>

            <h3>Exemplo de Frameworks</h3>
            <ol class="frameworks">
              <li>Django</li>
              <p>Um framework web completo ("batteries included") que fornece recursos integrados como ORM, sistema de autenticação e painel administrativo, ideal para desenvolver aplicações web de grande escala de forma rápida e segura.</p>

              <li>Flask</li>
              <p>Um microframework minimalista que oferece grande flexibilidade, permitindo que o desenvolvedor escolha e integre as bibliotecas necessárias. É excelente para a criação de APIs e protótipos de aplicações web.</p>
              
              <li>FastAPI</li>
              <p>Um framework moderno para a criação de APIs RESTful que aproveita a tipagem estática do Python. Ele proporciona alta performance e gera documentação automática, sendo ideal para aplicações que exigem escalabilidade e segurança.</p>

            </ol>
        </header>  
      </section>

      <section class="main-section">
        <header id="tipos_de_dados">
            <h2>Tipos de Dados</h2>
            <table>
              <thead>
                <tr>
                  <th>Tipo de dado</th>
                  <th>Descrição</th>
                  <th>Exemplo da sintaxe</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td class="type">bool</td>
                  <td>Booleano</td>
                  <td class="sintaxe">True or False</td>
                </tr>

                <tr>
                  <td class="type">int</td>
                  <td>Número de precisão fixa, é transparentemente convertido para "long" caso não caiba em um "int".</td>
                  <td class="sintaxe">42, 32, 8542</td>
                </tr>

                <tr>
                  <td class="type">float</td>
                  <td>Ponto flutuante</td>
                  <td class="sintaxe">3.1415927</td>
                </tr>

                <tr>
                  <td class="type">complex</td>
                  <td>Número complexo</td>
                  <td class="sintaxe">3+2j</td>
                </tr>

                <tr>
                  <td class="type">list</td>
                  <td>Lista heterogênea mutável</td>
                  <td class="sintaxe">[4.0, 'string', True]</td>
                </tr>

                <tr>
                  <td class="type">tuple</td>
                  <td>Tupla imutável</td>
                  <td class="sintaxe">(4.0, 'string', True)</td>
                </tr>

                <tr>
                  <td class="type">range</td>
                  <td>Sequência de números imutável que pode ser transformada em lista</td>
                  <td class="sintaxe">range(10), range(0, 10), range(0, 10, 1)</td>
                </tr>

                <tr>
                  <td class="type">set, frozenset</td>
                  <td>Conjunto não ordenado, não contém elementos duplicados</td>
                  <td class="sintaxe">{4.0, 'string', True}, frozenset([4.0, 'string', True])</td>
                </tr>

                <tr>
                  <td class="type">str, unicode</td>
                  <td>Uma cadeia de caracteres imutável</td>
                  <td class="sintaxe">'Python', u'Python'</td>
                </tr>

                <tr>
                  <td class="type">bytes, bytearray, memoryview</td>
                  <td>Sequência binária</td>
                  <td class="sintaxe">b'Python', bytearray(b'Python'), memoryview(b'Python')</td>
                </tr>

                <tr>
                  <td class="type">dict</td>
                  <td>Conjunto associativo</td>
                  <td class="sintaxe">{'key1': 1.0, 'key2': False}</td>
                </tr>
              </tbody>
            </table>
        </header>
      </section>

      <section class="main-section">
        <header id="compilador_de_bytecode">
           <h2>Compilador de bytecode</h2>
           <p>A linguagem é de altíssimo nível, como já dito, mas ela também pode compilar seus programas para que a próxima vez que o executar não precise compilar novamente o programa, reduzindo o tempo de carga na execução. Utilizando o interpretador interativo não é necessário a criação do arquivo de Python compilado, os comandos são executados interativamente. Porém quando um programa ou um módulo é evocado, o interpretador realiza a análise léxica e sintática, compila o código de alto nível se necessário e o executa na máquina virtual da linguagem. O bytecode é armazenado em arquivos com extensão .pyc ou .pyo, este último no caso de bytecode otimizado. Interessante notar que o bytecode da linguagem também é de alto nível, ou seja, é mais legível aos seres humanos que o código de byte do C, por exemplo. Para descompilar um código de byte é utilizado o módulo dis da biblioteca padrão da linguagem e existem módulos de terceiros que tornam o bytecode mais confuso, tornando a descompilação ineficaz.</p>
        </header>
      </section>

      <section class="main-section">
        <header id="python_poo">
           <h2>Programação Orientada a Objetos</h2>
           <p>A programação orientada a objetos (POO) é um paradigma que organiza o código em torno de "objetos", que são instâncias de "classes" representando entidades com atributos (dados) e métodos (funções). Python é uma linguagem multiparadigma que suporta POO, permitindo aos desenvolvedores modelar sistemas de forma modular e reutilizável.</p>
           <p>Em Python, uma classe é definida usando a palavra-chave class, e seus métodos recebem a instância atual como primeiro argumento, convencionalmente chamado de self</p>

           <h3>Definição de classe e objeto</h3>
           <div class="code-python">
            <p>class Animal:</p>
            <p>def __init__(self, nome, especie):</p>
            <p>self.nome = nome</p>
            <p>self.especie = especie</p>

            <p>def emitir_som(self):</p>
            <p>pass</p>
           </div>
            <p>Aqui, "Animal" é uma classe com um método construtor __init__ que inicializa os atributos nome e especie. O método "emitir_som" é definido, mas não implementado, indicando que subclasses devem fornecer sua própria versão deste método.</p>

            <h3>Herança</h3>
            <p>Python suporta herança, permitindo que classes derivadas herdem atributos e métodos de classes base.</p>
            <div class="code-python">
              <p>class Cachorro(Animal):</p>
              <p>def emitir_som(self):</p>
              <p>return "Latido"</p>
            </div>
            <p>Neste exemplo, "Cachorro" herda de "Animal" e implementa o método "emitir_som".</p>

            <h3>Encapsulamento</h3>
            <p>Embora Python não imponha rigorosamente o encapsulamento, convenciona-se prefixar atributos ou métodos com um sublinhado (_) para indicar que são de uso interno.</p>
            <div class="code-python">
              <p>class ContaBancaria:</p>
              <p>def __init__(self, saldo_inicial):</p>
              <p>self._saldo = saldo_inicial</p>

              <p>def depositar(self, quantia):</p>
              <p>self._saldo += quantia</p>

              <p>def sacar(self, quantia):</p>
              <p> if quantia <= self._saldo:</p>
              <p>self._saldo -= quantia</p>
              <p>return quantia</p>

              <p>else:</p>
              <p>raise ValueError("Saldo insuficiente")</p>
            </div>
            <p>"Aqui, _saldo" é considerado um atributo protegido, sugerindo que não deve ser acessado diretamente fora da classe.</p>
            <h3>Polimorfismo</h3>
            <p>Python permite polimorfismo, onde diferentes classes podem implementar métodos com o mesmo nome, e o comportamento específico é determinado pela classe da instância em uso.</p>
            <div>
              <p>animais = [Cachorro("Rex", "Canino"), Gato("Mia", "Felino")]</p>

              <p>for animal in animais:</p>
              <p>print(animal.emitir_som())</p>
            </div>
            <p>Neste caso, cada objeto animal invoca seu próprio método emitir_som, demonstrando polimorfismo.</p>

            <p>Python também suporta herança múltipla, permitindo que uma classe herde de múltiplas classes base. Além disso, classes, funções, números e módulos são todos considerados objetos em Python, refletindo sua natureza orientada a objetos.</p>
        </header>
      </section>

      <section class="main-section">
        <header id="python-ia">
          <h2>Inteligência Artificial</h2>
           <ol>
            <li>Coleta e Processamento de Dados</li>
            <p>Tudo começa com os dados. Em projetos de IA, geralmente trabalhamos com grandes volumes de dados provenientes de diversas fontes (bancos de dados, arquivos CSV, APIs, etc.). Python facilita essa coleta utilizando bibliotecas como pandas e NumPy, que permitem ler, filtrar e transformar dados de forma eficiente.</p>
            <p>Antes de alimentar um modelo de IA, os dados precisam ser limpos e organizados. Técnicas de pré-processamento como normalização, tratamento de valores ausentes e codificação de variáveis categóricas são realizadas com Python, preparando os dados para serem interpretados pelos algoritmos de aprendizado.</p>

            <li>Construção do modelo</li>
            <p>Com os dados prontos, o próximo passo é definir a arquitetura do modelo. Em Python, frameworks como TensorFlow e PyTorch permitem que você construa modelos de redes neurais de forma modular. Você pode definir camadas (densas, convolucionais, recorrentes, etc.), escolher funções de ativação (ReLU, Sigmoid, Softmax) e especificar a estrutura que melhor se adapta ao problema.</p>
            <p>Esses frameworks oferecem uma abordagem declarativa, onde você “desenha” a rede de forma intuitiva, especificando a sequência de operações matemáticas e transformações que os dados devem sofrer. Isso torna o código mais legível e facilita a experimentação com diferentes arquiteturas.</p>

            <li>Treinamento do Modelo</li>
            <p>O treinamento de um modelo de IA envolve ajustar os parâmetros (pesos e vieses) para minimizar o erro entre as previsões do modelo e os valores reais. Algoritmos de otimização, como o Gradient Descent, são utilizados para essa tarefa. Frameworks como TensorFlow e PyTorch automatizam o cálculo dos gradientes através de backpropagation, permitindo que você foque na experimentação com diferentes hiperparâmetros.</p>
            <p>Durante o treinamento, o modelo é iterativamente ajustado com base em métricas de desempenho (como acurácia, perda, etc.). Python facilita esse processo com loops de treinamento, validação e testes, e permite visualizações (usando Matplotlib ou Seaborn) que ajudam a monitorar a evolução do modelo.</p>

            <li>Validação e teste</li>
            <p>Uma vez treinado, o modelo precisa ser avaliado para garantir que ele generalize bem para dados novos. Em Python, técnicas de validação cruzada e conjuntos de teste são comumente utilizados para medir a performance do modelo.</p>
            <p>Métricas como precisão, recall, F1-score e curva ROC são calculadas para entender a eficácia do modelo. Essa etapa é fundamental para identificar se o modelo está sofrendo de overfitting ou underfitting.</p>

            <li>Deploy e inferência</li>
            <p>Após a validação, o modelo pode ser integrado em aplicações reais. Python permite criar APIs (por exemplo, com Flask ou FastAPI) que expõem o modelo para receber dados em tempo real e retornar previsões. Isso torna a IA acessível a outros sistemas e usuários finais.</p>
            <p>Apesar de Python ser uma linguagem interpretada, sua vasta gama de bibliotecas permite que partes críticas do código sejam otimizadas ou integradas com linguagens de baixo nível, garantindo desempenho mesmo em aplicações complexas.</p>

           </ol>
        </header>
      </section>

    </main>
</body>
</html>